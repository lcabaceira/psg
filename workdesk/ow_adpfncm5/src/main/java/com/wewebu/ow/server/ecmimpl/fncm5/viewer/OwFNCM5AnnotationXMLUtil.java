package com.wewebu.ow.server.ecmimpl.fncm5.viewer;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import com.wewebu.ow.server.util.OwXMLDOMUtil;

/**
 *<p>
 * Utility class for annotation specific XML handling.
 *</p>
 *
 *<p><font size="-2">
 * Alfresco Workdesk<br/>
 * Copyright (c) Alfresco Software, Inc.<br/>
 * All rights reserved.<br/>
 * <br/>
 * For licensing information read the license.txt file or<br/>
 * go to: http://wiki.alfresco.com<br/>
 *</font></p>
 */
public class OwFNCM5AnnotationXMLUtil
{
    private static final int LAST_6_BITS_MASK = 0x003F;
    private static final char ESCAPE_CHARACTER = '.';
    private static final char[] BASE_64_DIGITS = "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcde.fghijklmnopqrstuvwxyz0123456789".toCharArray();
    private static final int[] DECODE_TABLE_64 = new int[128];

    public static String toString(Node node_p) throws TransformerException
    {
        if (node_p.getNodeType() == Node.DOCUMENT_NODE)
        {
            node_p = ((Document) node_p).getDocumentElement();
        }

        String ret = OwXMLDOMUtil.toString(node_p);

        // remove <xml.. tag

        int iEnd = ret.indexOf(">");

        return ret.substring(iEnd + 1);
    }

    /**
     * Pick a sub node from a parent node using using the node's name.
     */
    public static Node getNodeNamed(Node parent_p, String name_p)
    {
        if (parent_p != null)
        {
            for (Node n = parent_p.getFirstChild(); n != null; n = n.getNextSibling())
            {
                if (name_p.compareTo(n.getNodeName()) == 0)
                {
                    return (n);
                }
            }
        }
        return (null);
    }

    /**
     * read the annotation date into a {@link Document}
     * @param request_p
     * @return a {@link Document}
     * @throws ParserConfigurationException 
     * @throws SAXException 
     * @throws IOException 
     */
    protected static Document readAnnotationData(HttpServletRequest request_p) throws IOException, SAXException, ParserConfigurationException
    {
        // get the size of the annotation stream
        String annoSize = request_p.getParameter("FnAnnoSize");
        double sizeD = Double.parseDouble(annoSize);
        int size = (int) sizeD;

        // get the number of annotations
        int fields = Integer.parseInt(request_p.getParameter("FnNumOfFields"));

        // now read the annotation stream into StringBuffer
        StringBuffer sb = new StringBuffer(size);
        for (int i = 1; i <= fields; i++)
        {

            String chunkNumber = i >= 10 ? Integer.toString(i) : "0" + i;
            String chunkKey = "FnAnnoData" + chunkNumber;
            String chunk = request_p.getParameter(chunkKey);
            sb.append(chunk);
        }

        String annotData = sb.toString();
        return OwXMLDOMUtil.getDocumentFromString(annotData);

    }

    /**
     * Encodes any String object so it can be used as a part of a URL
     * @param str_p string to be encoded
     * @return encoded String
     */
    public static String encodeLabel(String str_p)
    {
        if (str_p == null)
        {
            return null;
        }
        int len = str_p.length();
        StringBuffer sb = new StringBuffer(len);
        for (int i = 0; i < len; i++)
        {
            char ch = str_p.charAt(i);
            if ('a' <= ch && ch <= 'z')
            {
                sb.append(ch);
            }
            else if ('A' <= ch && ch <= 'Z')
            {
                sb.append(ch);
            }
            else if ('0' <= ch && ch <= '9')
            {
                sb.append(ch);
            }
            else if (ch == '*' || ch == '-' || ch == '_')
            {
                sb.append(ch);
            }
            else
            {
                sb.append(ESCAPE_CHARACTER);
                sb.append(BASE_64_DIGITS[ch >> 12]);
                sb.append(BASE_64_DIGITS[ch >> 6 & LAST_6_BITS_MASK]);
                sb.append(BASE_64_DIGITS[ch & LAST_6_BITS_MASK]);
            }
        }
        return sb.toString();
    }

    /**
     * Decodes a String generated by encodeLabel() method
     * @param str_p String to be decoded
     * @return decoded String
     */
    public static String decodeLabel(String str_p)
    {
        if (str_p == null)
        {
            return null;
        }
        int len = str_p.length();
        char[] source = str_p.toCharArray();
        StringBuffer sb = new StringBuffer(len);
        for (int i = 0; i < len; i++)
        {
            char ch = source[i];
            if (ch == ESCAPE_CHARACTER) //decode next three characters
            {
                int d3 = DECODE_TABLE_64[source[++i]] << 12; // * 4096
                int d2 = DECODE_TABLE_64[source[++i]] << 6; // * 64
                int d1 = DECODE_TABLE_64[source[++i]];
                sb.append((char) (d1 + d2 + d3));
            }
            else
            {
                sb.append(ch);
            }
        }
        return sb.toString();
    }

    /**
     * serialize the node into a string
     * @param node_p
     * @return a <code>String</code>
     * @throws TransformerException 
     */
    public static String saveToString(Node node_p) throws TransformerException
    {
        return toString(node_p);
    }

    /**
     * Create a node with a name.
     */
    public static Element createNodeNamed(Node parentNode_p, String name_p)
    {
        Document ownerDocument = parentNode_p.getOwnerDocument();
        Element newNode = ownerDocument.createElement(name_p);
        parentNode_p.appendChild(newNode);
        parentNode_p.appendChild(ownerDocument.createTextNode("\n"));

        return newNode;
    }

    /**
     * Pick an attribute from a node using using the name.
     * @param item_p
     * @param name_p
     * @return the attribute name as <code>String</code>
     */
    public static String getAttributeNamed(Node item_p, String name_p)
    {
        String result = "";

        if ((item_p != null) && (item_p.getNodeType() == Node.ELEMENT_NODE))
        {
            NamedNodeMap al = item_p.getAttributes();
            for (int i = 0; i < al.getLength(); i++)
            {
                if (al.item(i).getNodeName().equalsIgnoreCase(name_p))
                {
                    result = al.item(i).getNodeValue();
                }
            }
        }
        return result;
    }

}
